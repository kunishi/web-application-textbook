# HTTP

## HTTP: HyperText Transfer Protocol
- HyperText = ハイパーテキスト（ハイパーメディアの前身となった考え方。複数のテキスト文書をリンクで結んだもの。Webが開発された当初は、Webページにはテキストしか使えなかったため、この言葉が使われたものと思われる）
- アプリケーション層のプロトコルの一つ。トランスポート層にはTCPを想定
- ポート番号のデフォルトは80
- 現在のHTTPでは、クライアントからのリクエストに対してサーバがレスポンスを返す
  - クライアントが通信の起点
  - 半二重通信
  - 1回のHTTP通信では1つのURIのデータしか取得することができない
  - 多数のデータを並行して取得するには、TCP接続を複数確立する必要がある
  - 注：次世代HTTPでは、この辺りが変更される可能性が大。詳細は後述。

### クライアント側の処理手順
1. （HTTP通信が始まる前に、TCP接続を確立しておく必要あり）
2. リクエストメッセージの構築
3. リクエストメッセージの送信
4. （サーバからレスポンスが返るまで待機）
5. レスポンスメッセージの受信
6. レスポンスメッセージの解析
7. クライアント側でのデータ処理
### サーバ側の処理手順
1. （HTTP通信が始まる前に、TCP接続を確立しておく必要あり）
2. （クライアントからのリクエストを待機）
3. リクエストメッセージの受信
4. リクエストメッセージの解析
5. 適切なアプリケーションプログラムへ処理を委譲
6. アプリケーショムから結果を取得
7. レスポンスメッセージの構築
8. レスポンスメッセージの送信
### HTTPの歴史
- HTTP 1.0以前…初期のWebでは、メッセージのヘッダがない、HTTPメソッドはGETのみ、など、非常に単純なプロトコルであった。
- HTTP 1.0：1996年にRFC1945として制定。現在のHTTPの基本的な要素が取り込まれている。
- HTTP 1.1：1997年にRFC2068として制定、1999年にRFC2616として改訂。現在のHTTPはほとんどすべて HTTP 1.1 と考えて良い。本講義の内容はこのバージョンに沿っている。
- HTTP 2.0：現在検討中の次世代HTTP。通信の高速化を目的として全二重通信が導入される予定であり、その結果、サーバを起点とする通信も可能となる見込み。本講義では詳細は省略する。
## HTTPの基本思想
アプリケーション層の通信プロトコルの場合、ステートフル（stateful）な通信なのか、ステートレス（stateless）な通信なのかに注意しなければならない。
ステートフル：サーバがクライアントのアプリケーション状態を保存する
ステートレス：サーバがクライアントのアプリケーション状態を保存しない
これでは分かりにくいと思われるので、山本陽平氏による喩え話を転載しよう。ハンバーガーショップでの客と店員のやりとりの例である。
ステートフルサーバとステートレスサーバはどう違うのか。
まずは、ステートフルの例:
客: こんにちは
店員: いらっしゃいませ。○○バーガーへようこそ
客: ハンバーガーセットをお願いします
店員: サイドメニューは何になさいますか?
客: ポテトで
店員: ドリンクは何になさいますか?
客: ジンジャーエールで
店員: +50円でドリンクをLサイズにできますがいかがですか?
客: Mでいいです
店員: 以上でよろしいですか?
客: はい
店員: かしこまりました
これはいたって普通の会話に見える。では、ステートレスな場合はどうなのか。
客: こんにちは
店員: いらっしゃいませ。○○バーガーへようこそ
客: ハンバーガーセットをお願いします
店員: サイドメニューは何になさいますか?
客: ハンバーガーセットをポテトでお願いします
店員: ドリンクは何になさいますか?
客: ハンバーガーセットをポテトとジンジャーエールでお願いします
店員: +50円でドリンクをLサイズにできますがいかがですか?
客: ハンバーガーセットをポテトとジンジャーエール(M)でお願いします
店員: 以上でよろしいですか?
客: ハンバーガーセットをポテトとジンジャーエール(M)でお願いします。以上
店員: かしこまりました
これを見ると、以下のことが分かる。
ステートフルなやりとりでは、店員（サーバ）が客（クライアント）のそれまでの注文を覚えている
ステートレスなやりとりでは、客（クライアント）は毎回すべての注文を繰り返している
FTP（File Transfer Protocol、ファイル転送に広く用いられるプロトコル）やSMTP（Simple Mail Transfer Protocol、メール配送に用いられるプロトコル）など、アプリケーション層のプロトコルはほとんどがステートフルである。ところが、HTTPは原則的にステートレスなプロコトルである。
HTTPメッセージ
クライアントからサーバに送られるデータをリクエストメッセージ、サーバからクライアントに送られるデータをレスポンスメッセージという。これらをまとめてHTTPメッセージという。
リクエストメッセージ、レスポンスメッセージともに、3つの部分から構成される。
HTTPメッセージの例
リクエストメッセージ
リクエストヘッダの下に改行が1行あることに注意すること。後述のように、この空行は必須である。
GET /index.html HTTP/1.1
Host: www.example.com:8000
	
レスポンスメッセージ
HTTP/1.1 200 OK 
Content-Type: text/html; charset=utf-8

<html><body>I'm WEBrick.</body></html>
リクエストメッセージ
リクエストライン：メッセージの1行目。HTTPメソッド、リクエストURI、プロトコルバージョン
HTTPメソッド：リクエストURIで指定されたリソースに対して行いたい処理。上の例ではGET（リソースの取得）が指定されている。
リクエストURI：上の例のようにパスだけが指定される場合、完全な形のURIが指定される場合、いずれもある。
プロトコルバージョン：上の例ではHTTP/1.1（HTTP バージョン1.1）が指定されている。
リクエストヘッダ：リクエストラインに続き、2行目から置かれる。メッセージの付加情報を表す。各行ごと「ヘッダ名: 値」という形式になっている。
上の例では、Hostヘッダに値 www.example.com:8000 が指定されている。
リクエストボディ：リクエストメッセージの本体。ない場合もある。リクエストヘッダとリクエストボディは空行1つで区切られる。
上の例にはリクエストボディはない。
レスポンスメッセージ
ステータスライン：レスポンスメッセージの1行目。プロトコルバージョン、ステータスコード、テキストフレーズ
プロトコルバージョン：上の例ではHTTP/1.1（HTTP バージョン1.1）が指定されている。
ステータスコード：リクエストの結果を表す数値コード。上の例では200（成功）が指定されている。ステータスコードについては後述。
テキストフレーズ：自然言語によるステータスコードの説明。上の例では「OK」が指定されている。
レスポンスヘッダ：メッセージの付加情報。リクエストヘッダと同様「名前:値」という形をしている。
上の例では Content-Typeヘッダに text/html; charset=utf-8 という値が指定されている。
レスポンスボディ：メッセージ本体。ない場合もある。レスポンスヘッダとレスポンスボディは空行1つで区切られる。
上の例ではHTMLデータ「<html><body>I'm WEBrick.</body></html>」がレスポンスボディに置かれている。
HTTPメソッド
URIで指定した資源に対して行いたい処理を指定
主なHTTPメソッド
GET: 指定したURIの情報を取得する
例：GET http://blog.example.com/1 …URIで指定された記事の内容を取得する
POST: 指定したURIに対する子資源の作成など
例：POST http://blog.example.com/ … ブログ http://blog.example.com/ に新しい投稿という子資源を作成する
PUT: 資源の更新
例：PUT http://blog.example.com/1 … ブログの投稿 http://blog.example.com/1 の修正版を投稿する
DELETE: 資源の削除
例：DELETE http://blog.example.com/1 …ブログの投稿 http://blog.example.com/1 を削除する
HTMLフォームから発行できるHTTPメソッドはGET, POSTのみ
これ以外のメソッドを発行する場合は何らかのプログラムを通さなければならない
PUT, DELETEをPOSTで代用することもある
ステータスコード
3桁の数字
1xx: 処理中…処理が継続していることを示す。
クライアントはそのままリクエストを継続するなどの処理を行う
2xx: リクエスト成功…リクエストが成功したことを示す
200 OK: リクエスト成功。GETに対してリクエストが成功した場合は、レスポンスボディにその資源の内容が入る。
3xx: リダイレクト。他の資源への転送
クライアントはレスポンスヘッダ中のLocationヘッダを参照して、新しい資源に対するリクエストを行う
301 Moved Permanently: リソースの恒久的な移動
4xx: クライアントエラー…原因はクライアント側のリクエストにある
404 Not Found: リソースの不在
5xx: サーバエラー…原因はサーバ側にある
500 Internal Server Error: サーバ側に何らかの異常が起こっている
リクエストメッセージ、レスポンスメッセージの代表的なヘッダ
Date: Tue, 06 Jul 2010 03:21:05 GMT … メッセージを作成した日時
Location: www.example.com … リクエストを送るサーバ名が www.example.com である
Content-Type: text/html; charset=utf-8 … メッセージのボディの内容を表す。この例ではHTML形式のテキスト（text/html）で、文字エンコーディングがUTF-8であることを表している。
Content-Length: 5538 … メッセージボディのバイト数が5538バイトである
Authorization: Basic dXNlcjpwYXNzd29yZA== … 資源にパスワードによる認証が必要な場合、認証に必要なユーザ名とパスワードを送信する。この例では認証方式（Basic認証）とユーザ名、パスワード（dXNlcjpwYXNzd29yZA==の部分。ユーザ名とパスワードをBase64エンコーディングと呼ばれる方式で符号化している。この例では user:password という文字列をエンコードしている）
Webで扱われるデータ
サーバとクライアントでデータ形式について合意さえ取れていれば（すなわちサーバとクライアントが共に分かる形式のデータであれば）、どんなデータでも扱うことができる。現在よく使われるデータは次のようなものがある。

テキスト形式
ブラウザで表示させるテキスト…HTML, XHTML
主にブラウザで表示させず、プログラムで処理することを主目的とするテキスト…Atom, RSS, JSON
画像…Jpeg, GIF, PNGなど
音声…MP3 (MPEG Audio Layer-3), MPEG4-AACなど
動画…MPEG4, H.264, WebMなど
TCPコネクションの継続（Keep alive）
Keep alive
１まとまりのHTTPリクエストの間TCPコネクションを切らない
HTTP 1.1ではこれがデフォルトの挙動になっている
TCPハンドシェイクの時間を短縮→通信の高速化
クライアント、サーバのいずれかから Connection: close をヘッダで送信するまでTCPコネクションを継続
