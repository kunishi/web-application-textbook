# HTTP(Hypertext Transfer Protocol)

## プロトコルの概要

* HyperText = ハイパーテキスト（ハイパーメディアの前身となった考え方。複数のテキスト文書をリンクで結んだもの。Webが開発された当初は、Webページにはテキストしか使えなかったため、この言葉が使われたものと思われる）
* アプリケーション層のプロトコルの一つ。トランスポート層にはTCPを想定
* ポート番号のデフォルトは80
* 現在のHTTPでは、クライアントからのリクエストに対してサーバがレスポンスを返す
  * クライアントが通信の起点
  * 半二重通信
  * 1回のHTTP通信では1つのURIのデータしか取得することができない
  * 多数のデータを並行して取得するには、TCP接続を複数確立する必要がある
  * 注：次世代HTTPでは、この辺りが変更される可能性が大。詳細は後述。


### クライアント側の処理手順

1. （HTTP通信が始まる前に、TCP接続を確立しておく必要あり）
2. リクエストメッセージの構築
3. リクエストメッセージの送信
4. （サーバからレスポンスが返るまで待機）
5. レスポンスメッセージの受信
6. レスポンスメッセージの解析
7. クライアント側でのデータ処理

### サーバ側の処理手順

1. （HTTP通信が始まる前に、TCP接続を確立しておく必要あり）
2. （クライアントからのリクエストを待機）
3. リクエストメッセージの受信
4. リクエストメッセージの解析
5. 適切なアプリケーションプログラムへ処理を委譲
6. アプリケーショムから結果を取得
7. レスポンスメッセージの構築
8. レスポンスメッセージの送信

### HTTPの歴史

* HTTP 1.0以前…初期のWebでは、メッセージのヘッダがない、HTTPメソッドはGETのみ、など、非常に単純なプロトコルであった。
* HTTP 1.0：1996年にRFC1945として制定。現在のHTTPの基本的な要素が取り込まれている。
* HTTP 1.1：1997年にRFC2068として制定、1999年にRFC2616として改訂。現在のHTTPはほとんどすべて HTTP 1.1 と考えて良い。本講義の内容はこのバージョンに沿っている。
* HTTP 2.0：現在検討中の次世代HTTP。通信の高速化を目的として全二重通信が導入される予定であり、その結果、サーバを起点とする通信も可能となる見込み。本講義では詳細は省略する。

## HTTPの基本思想

先に述べた通り、HTTPはステートレスサーバのアーキテクチャスタイルに従っており、原則としてサーバはクライアントのアプリケーション状態を保存しない。

ユーザ認証など、ステートレスにできない用途もあるが、極力アプリケーション状態の保存は最小に留める、という思想でアプリケーションが設計されることが多い。

論理的には、URIで指定された資源に対して操作(HTTPメソッド)を送り、サーバ側で対応する操作をした結果（成功・失敗、成功の場合は操作結果、失敗の場合はその原因など）をクライアントに返す。

## HTTPメソッド

* URIで指定した資源に対して行いたい処理を指定
* 主なHTTPメソッド
  * GET: 指定したURIの情報を取得する
    * 例：`GET http://blog.example.com/1` …URIで指定された記事の内容を取得する
  * POST: 指定したURIに対する子資源の作成など
    * 例：`POST http://blog.example.com/` … URI `http://blog.example.com/` に新しい投稿という子資源を作成する
  * PUT: 資源の更新
    * 例：`PUT http://blog.example.com/1` … URI `http://blog.example.com/1`  のデータを修正する
  * DELETE: 資源の削除
    * 例：`DELETE http://blog.example.com/1` …URI `http://blog.example.com/1` を削除する
* このように、HTTPメソッドの`GET`, `POST`, `PUT`, `DELETE`は、データに対する代表的な操作であるCRUD(create, read, update, delete)に対応している。
* そのほかのHTTPメソッド
  * `HEAD`, `OPTIONS`, `TRACE`, `CONNECT`, `PATCH`
  * `PATCH`は2010年に発行された[RFC5789](https://tools.ietf.org/html/rfc5789)で新しく追加されたHTTPメソッドである
* HTMLフォームから発行できるHTTPメソッドはGET, POSTのみ
  * これ以外のメソッドを発行する場合は何らかのプログラムを通さなければならない
  * PUT, DELETEをPOSTで代用することもある

## ステータスコード

リクエストメッセージに対応する処理をサーバ上でした結果（成功・失敗、失敗ならその原因など）をクライアントに通知する3桁の数字である。主なものを以下に示す。

* 1xx: 処理中…処理が継続していることを示す。
* クライアントはそのままリクエストを継続するなどの処理を行う
* 2xx: リクエスト成功…リクエストが成功したことを示す
  * `200 OK`: リクエスト成功。GETに対してリクエストが成功した場合は、レスポンスボディにその資源の内容が入る。
* 3xx: リダイレクト。他の資源への転送
  * クライアントはレスポンスヘッダ中のLocationヘッダを参照して、新しい資源に対するリクエストを行う
  * `301 Moved Permanently`: リソースの恒久的な移動
* 4xx: クライアントエラー…原因はクライアント側のリクエストにある
  * `404 Not Found`: リソースの不在
* 5xx: サーバエラー…原因はサーバ側にある
  * `500 Internal Server Error`: サーバ側に何らかの異常が起こっている

## HTTPメッセージ

クライアントからサーバに送られるデータをリクエストメッセージ、サーバからクライアントに送られるデータをレスポンスメッセージという。これらをまとめてHTTPメッセージという。

リクエストメッセージ、レスポンスメッセージともに、以下の2つの部分から構成される。

* ヘッダ: メッセージの付加情報。HTTPメソッドやステータスコードなどもこの部分に描かれる。
* ボディ: メッセージでやりとりされるデータ本体。

ヘッダとボディとの間には必ず1行の空行が置かれる。またボディは省略される（何もない）こともある。

使える文字にも制限がある。ヘッダ内ではASCII文字のみ、ボディ内ではテキストのみが許される。

### リクエストメッセージ

この例は、URI `http://www.example.com:8000/index.html` に `GET`メソッドを送信する、すなわち `http://www.example.com:8000/index.html` の内容を取得するときに送信されるリクエストメッセージである。

この場合、ボディは何もなく、ヘッダの後ろに1行空行があるという形式になる。

```
GET /index.html HTTP/1.1
Host: www.example.com:8000

```

* リクエストライン：メッセージの1行目。HTTPメソッド、リクエストURI、プロトコルバージョン
  * HTTPメソッド：リクエストURIで指定されたリソースに対して行いたい処理。上の例では`GET` （リソースの取得）が指定されている。
  * リクエストURI：上の例のようにパスだけが指定される場合、完全な形のURIが指定される場合、いずれもある。
  * プロトコルバージョン：上の例では `HTTP/1.1` （HTTP バージョン1.1）が指定されている。
  * リクエストヘッダ：リクエストラインに続き、2行目から置かれる。メッセージの付加情報を表す。各行ごと「ヘッダ名: 値」という形式になっている。
  * 上の例では、Hostヘッダに値 `www.example.com:8000` が指定されている。
* リクエストボディ：リクエストメッセージの本体。ない場合もある。リクエストヘッダとリクエストボディは空行1つで区切られる。
  * 上の例にはリクエストボディはない。

### レスポンスメッセージ

上に示したリクエストメッセージに対し、データ（URIで示されたHTMLページ）があった場合、次のようなレスポンスメッセージがサーバからクライアントに送信される。

```
HTTP/1.1 200 OK 
Content-Type: text/html; charset=utf-8

<html><body>I'm WEBrick.</body></html>
```

* ステータスライン：レスポンスメッセージの1行目。プロトコルバージョン、ステータスコード、テキストフレーズ
  * プロトコルバージョン：上の例では`HTTP/1.1`（HTTP バージョン1.1）が指定されている。
  * ステータスコード：リクエストの結果を表す数値コード。上の例では`200`（成功）が指定されている。ステータスコードについては後述。
  * テキストフレーズ：自然言語によるステータスコードの説明。上の例では`OK`が指定されている。
* レスポンスヘッダ：メッセージの付加情報。リクエストヘッダと同様「名前:値」という形をしている。
  * 上の例では Content-Typeヘッダに `text/html; charset=utf-8` という値が指定されている。
* レスポンスボディ：メッセージ本体。ない場合もある。レスポンスヘッダとレスポンスボディは空行1つで区切られる。
  * 上の例ではHTMLデータ「`<html><body>I'm WEBrick.</body></html>`」がレスポンスボディに置かれている。

### HTTPメッセージの代表的なヘッダ

どれも「名前: 値」という形式をしている。このような欄が必要に応じていくつもヘッダ内に置かれる。

* `Date: Tue, 06 Jul 2010 03:21:05 GMT` … メッセージを作成した日時
* `Host: www.example.com` … リクエストを送るサーバ名が `www.example.com` である
* `Content-Type: text/html; charset=utf-8` … メッセージのボディの内容を表す。この例ではHTML形式のテキスト（`text/html`）で、文字エンコーディングがUTF-8であることを表している。
* `Content-Length: 5538` … メッセージボディのバイト数が5538バイトである
* `Authorization: Basic dXNlcjpwYXNzd29yZA==` … 資源にパスワードによる認証が必要な場合、認証に必要なユーザ名とパスワードを送信する。この例では認証方式（Basic認証）とユーザ名、パスワード（`dXNlcjpwYXNzd29yZA==`の部分。ユーザ名とパスワードを[Base64エンコーディング](https://ja.wikipedia.org/wiki/Base64)と呼ばれる方式で符号化している。この例では `user:password` という文字列をエンコードしている）

## 例

### バイナリデータの送信

`http://example.com/photo.jpg` に対して`GET`メソッドを送る、という例を考える。直感的には、画像データ`photo.jpg`を取得するという例である。

ボディにはテキストしか使えないので、画像のようなバイナリデータをそのまま埋め込むことはできない。そこで、元のバイナリデータを[Base64エンコード](https://ja.wikipedia.org/wiki/Base64)によって符号化（encode）したテキストデータをボディに埋め込む。

```
HTTP/1.1 200 OK
Content-Type: image/jpeg

(photo.jpgをBase64エンコードしたテキスト）
```

これを受け取ったクライアントは、ボディをBase64方式でデコードし、元の画像データを取り出す。

### 200以外のステータスコード

ステータスコードが200以外の場合、ボディには、処理結果の詳細情報が埋め込まれる。何も埋め込まれない、というケースは稀である。

例えば、`http://example.com/index.html` に対して `GET` メソッドを送ったところ、対応するリソースがなかった場合、次のようなレスポンスメッセージが返ってくる。

```
HTTP/1.1 404 Not Found
Content:Type: text/html

<html><body>該当するページが見つかりません</body></html>
```

## TCPコネクションの継続（Keep alive）

* Keep alive
  * １まとまりのHTTPリクエストの間TCPコネクションを切らない
  * HTTP 1.1ではこれがデフォルトの挙動になっている
  * TCPハンドシェイクの時間を短縮→通信の高速化
  * クライアント、サーバのいずれかから Connection: close をヘッダで送信するまでTCPコネクションを継続


