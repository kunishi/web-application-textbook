# HTTPクッキーと認証
ここまで述べたようにHTTPはステートレスなプロトコルであり、クライアント状態をサーバが保存することはない。しかし現実のアプリケーションでは、サービスへのログインなど、何らかのクライアント状態によってサーバの振る舞いを変えるニーズが存在する。

本章ではまずHTTPクッキーについて述べ、クライアント状態の典型例であるユーザ認証の実現方法をいくつか示す。

## HTTPクッキー
**HTTPクッキー**（HTTP cookie）[^1]は、Webサーバ上の情報をWebクライアントに保存しHTTPで利用するための汎用技術であり、これによりHTTPにおいて状態を実現することができる。1994年に、当時大きなシェアを持っていたWebブラウザNetscape Navigatorの開発元であるNetscape Communications社によって提案・実装された。その後IETFによる国際標準化が行われ、2011年に発行された[RFC 6265](https://tools.ietf.org/html/rfc6265)が最新版である。

[^1]: クッキーと略されることもある。

HTTPクッキーは、レスポンスメッセージにおける`Set-Cookie`ヘッダ、リクエストメッセージにおける`Cookie`ヘッダという2つのヘッダによって実現される。あるWebサーバから`Set-Cookie`ヘッダを付けてレスポンスメッセージを送信すると、以降、このレスポンスメッセージを受け取ったWebクライアントからそのWebサーバへリクエストメッセージを送信するときには`Cookie`ヘッダを付け、その中に、`Set-Cookie`ヘッダに含まれていた情報を含める。

例を示そう。Webブラウザから`http://example.jp/sample`にHTTPリクエストを送信したところ、そのレスポンスに次のヘッダが含まれていたとする。

```
Set-Cookie: SID=31d4d96e407aad42
```

このヘッダの中身`SID=31d4d96e407aad42`がHTTPクッキーであり、この例では名前`SID`の値が`31d4d96e407aad42`であることを示している。

このレスポンスメッセージを受け取ったWebブラウザは、以降、`http://example.jp/sample`にHTTPリクエストを送信する場合には次のヘッダを必ず付ける。

```
Cookie: SID=31d4d96e407aad42
```

HTTPクッキーには、有効期限、URIに関する有効範囲（ホスト名、パス）、セキュリティ上の制限（HTTPSでのみ有効、JavaScriptからのアクセス不可）などを付与することができる。次の例は、有効期限をグリニッジ標準時2021年6月9日10時18分14秒までとし、かつ`http://example.jp/`で始まるすべてのURIに対して同じHTTPクッキーを付与するという例である。

```
Set-Cookie: SID=31d4d96e407aad42; Path=/; Expires=Wed, 09 Jun 2021 10:18:14 GMT
```

なお、これらの制限は、リクエストメッセージ中の`Cookie`ヘッダには含まれない。

```
Cookie: SID=31d4d96e407aad42
```

HTTPクッキーを削除したい場合は、空のクッキーを送信したり、有効期限を過去に設定したクッキーを送信する。

```
Set-Cookie: SID=31d4d96e407aad42; Path=/; Expires=Sun, 06 Nov 1994 08:49:37 GMT
```

現実のWebクライアントではクッキーの数や容量に制限がある。RFC 6265では、Webクライアントを実装する場合には、次の条件を最低限守るべきだとしている。

* 一つのクッキー（名前と値のペア）の大きさが4096バイト以上扱えること
* 1ドメインあたりのクッキー数を50以上扱えること
* クッキー総数を3000以上扱えること

## HTTPで規定されている認証方式
HTTP/1.1には、Basic認証とDigest認証というユーザ認証方式が規定されている（[RFC 2617](https://tools.ietf.org/html/rfc2617)）。これらはいずれもHTTPクッキーを使わない。

Basic認証とDigest認証では、いずれも、まず最初に認証なしのHTTPリクエストをサーバに送信し、ステータスコード`401 Unauthorized`のHTTPレスポンスを得る。そして、そのレスポンス中に含まれている情報を用いて認証付きのHTTPリクエストを送信する。

### Basic認証
Basic認証では、認証のためのユーザIDとパスワードをBase64エンコーディングした文字列をリクエストヘッダに含める。

例を示そう。まず認証なしのHTTPリクエストをサーバ`example.jp`に送信する。

```
GET / HTTP/1.1
Host: example.jp
```

すると`example.jp`は、このURIにアクセスするにはBasic認証が必要であるという情報を`WWW-Authentication`ヘッダにつけて、`401 Unauthorized`のHTTPレスポンスを返す。`realm`にはWebサーバ上でこの認証につけられた名前が記されている。

```
HTTP/1.1 401 Unauthorized
WWW-Authentication: Basic realm="WallyWorld"
```

このHTTPレスポンスを受け取ったWebクライアントは、ユーザに、認証に必要となるユーザ名とパスワードを入力するよう促す[^1]。

[^1]: 多くのWebブラウザでは、ポップアップウィンドウを表示して、その中にユーザ名とパスワードを入力させるようにしている。

ユーザ名とパスワードを受け取ると、Webクライアントはこれらを`:`で連結してBase64エンコードし、`Authorization`ヘッダに格納して再度HTTPリクエストを行う。以下の例では、`taro:pass`（ユーザ名`taro`、パスワード`pass`）をBase64エンコードした文字列`dGFybzpwYXNzCg==`が格納されている。

```
GET / HTTP/1.1
Host: example.jp
Authorization: Basic dGFybzpwYXNzCg==
```

このリクエストを受け取ったWebサーバは、`dGFybzpwYXNzCg==`をBase64デコードしてユーザ名とパスワードを取得し、ユーザ認証を行う。

多くのWebクライアントでは、ユーザによって入力されたユーザ名とパスワードを内部で保存しており、2回目以降のHTTPリクエストでは、ユーザからの入力なしに`Authorization`ヘッダを付与することが多い。

## HTTPクッキーを用いた認証

- 実現方法
    - セッション一つ一つに固有のID（セッションID）を振る
    - セッション開始時にセッションIDをクッキーとして送信
- 認証の例
    - ブラウザ→サーバ：ID/パスワードを送信
    - サーバ：認証（DBチェック）
    - サーバ→ブラウザ：認証が成功したら、新たなセッションIDを発行してクッキーとして送信
    - ブラウザ→サーバ：以降、ログアウトするまでセッションIDを付与して送信
    - ブラウザ→サーバ：ログアウト時にクッキーの無効化